from algorithm.constructive import SimpleConstructive
from model.classes import Engine
from model.problem import Problem
from model.solution import Solution
from .move import Move
from typing import Optional, List, Tuple
import random


class Swap(Move):
    """This class represents a Swap Move. A neighbor in the Swap Neighborhood 
    is generated by swapping two jobs between two machines. Note that the 
    swapped jobs may be placed in any position on the other machine, i.e. the 
    original positions are not taken into account. This Move first removes the 
    two jobs and then reinserts them in random positions.
    """ 	
    
    def __init__(
        self: 'Swap', 
        problem: Problem, 
        constructive: SimpleConstructive
    ):
        """Instantiates a new Swap Move.

        Args:
            problem (Problem): The problem reference.
            constructive (SimpleConstructive): The move constructive procedure.
        """

        super().__init__(problem, constructive,'Swap')

        self._engine_1: Engine = random.choice(problem.engines)
        self._engine_2: Engine

        # try to get the engine from the neighboring yard
        index: int = problem.engines.index(self._engine_1)
        try:
            self._engine_2 = problem.engines[index + 1]

        except IndexError:
            self._engine_2 = problem.engines[index - 1]

        finally:
            self._engine_2 = random.choice(problem.engines)

        self._route_1: List[Tuple[int, str]] = \
            self._current_solution.routes[self._engine_1.id - 1]
        self._route_2: List[Tuple[int, str]] = \
            self._current_solution.routes[self._engine_2.id - 1]

        self._job_1: Tuple[int, str] = random.choice(self._route_1)
        self._job_2: Tuple[int, str] = random.choice(self._route_2)

        self._pos_1: int = self._route_1.index(self._job_1)
        self._pos_2: int = self._route_2.index(self._job_2)

    def accept(self: 'Swap') -> None:
        """This method must be called whenever the modification made by 
        this move is accepted. It ensures that the solution as well as 
        other structures are updated accordingly.
        """

        super().accept()

    def reject(self: 'Swap') -> None:
        """This method must be called whenever the modification made by 
        this move are rejected. It ensures that the solution as well as 
        other structures are updated accordingly.
        """

        super().reject()

        self._route_1.remove(self._job_1)
        self._route_2.remove(self._job_2)

        self._route_1.insert(self._pos_1, self._job_1)
        self._route_2.insert(self._pos_2, self._job_2)

        self._constructive.run(True)

    def do_move(self: 'Swap', solution: Solution) -> float:
        """This method returns does the move and returns the impact 
        (delta cost) in the solution.
    
        Args:
            solution (Solution): The solution to be modified.

        Returns:
            int: The impact (delta cost) of this move in the solution.
        """

        super().do_move(solution)

        self._route_1.remove(self._job_1)
        self._route_2.remove(self._job_2)

        self._route_1.insert(random.randrange(len(self._route_1)), self._job_2)
        self._route_2.insert(random.randrange(len(self._route_2)), self._job_1)

        self._constructive.solution = solution
        self._constructive.run(True)

        self._delta_cost = solution.cost - self._initial_cost

        return self._delta_cost

    def has_move(self: 'Switch', solution: Solution) -> bool:
        """This method returns a boolean indicating whether this neighborhood 
        can be applied to the current solution.

        Args:
            solution (Solution): The solution to be evaluated.
        
        Returns:
            bool: True if this neighborhood can be applied to the current 
                solution, False otherwise.
        """

        if self._engine_1.speed_reclaim > 0 and self._engine_2.speed_reclaim > 0 \
        or self._engine_1.speed_stack > 0 and self._engine_2.speed_stack > 0:
            return True

    def reset(self: 'Swap') -> None:
        """This method is called whenever the neighborhood should be reset 
        (mainly to avoid the need of creating another object).
        """

        self._engine_1 = random.choice(self._problem.engines)

        # try to get the engine from the neighboring yard
        index: int = self._problem.engines.index(self._engine_1)
        try:
            self._engine_2 = self._problem.engines[index + 1]

        except IndexError:
            self._engine_2 = self._problem.engines[index - 1]

        finally:
            self._engine_2 = random.choice(self._problem.engines)

        self._job_1 = random.choice(self._route_1)
        self._job_2 = random.choice(self._route_2)

        self._pos_1 = self._route_1.index(self._job_1)
        self._pos_2 = self._route_2.index(self._job_2)
